#!/usr/bin/python

### make-case-conv.py --- generate case-conversion info from the Unicode database

## Copyright (C) 2010 Ben Wing.

## Author: Ben Wing <ben@xemacs.org>
## Maintainer: Ben Wing <ben@xemacs.org>
## Current Version: 1.0, January 25, 2010

## This file is part of XEmacs.

## XEmacs is free software; you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.

## XEmacs is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with XEmacs; see the file COPYING.  If not, write to the Free
## Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
## 02111-1307, USA.

### Commentary:

# This file parses the file CaseFolding.txt in Unicode's UNIDATA package,
# and generates a Lisp file containing instructions to set all the case
# mappings in the standard case table.

# To run this file, redirect its stdout to the file mule/uni-case-conv.el
# (or whatever else you have named it according to the variable
# `output_filename').

### Code:

import urllib2, re, sys
#import fileinput

# The URL holding the case-folding table at www.unicode.org.
uni_casefold_url = 'http://www.unicode.org/Public/UNIDATA/CaseFolding.txt'

# Path to this file, as will appear in the comments of the generated file
our_filepath = 'lib-src/make-case-conv.py'

# Name of the generated file (no directories in it)
output_filename = 'uni-case-conv.el'

def argformat(format, arg):
    if type(format) is str:
        return format % arg
    else:
        return str(format)

# Write formatted arguments to stdout.
def outout(format, *arg):
    sys.stdout.write(argformat(format, arg))

# Write formatted arguments to stderr.
def errout(format, *arg):
    sys.stderr.write(argformat(format, arg))



print """\
;;; %s --- Case-conversion support for Unicode

;; Copyright (C) 2010 Ben Wing.

;; Keywords: multilingual, case, uppercase, lowercase, Unicode

;; This file is part of XEmacs.

;; XEmacs is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; XEmacs is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with XEmacs; see the file COPYING.  If not, write to the Free
;; Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
;; 02111-1307, USA.

;;; Commentary:

;; DO NOT MODIFY THIS FILE!!!!!!!!!!!!!!!!
;; This file is autogenerated by %s.  Modify that
;; file instead.

;;; Code:

(loop
  for (upper lower)
  in '(
""" % (output_filename, our_filepath),

#for line in fileinput.input():
for line in urllib2.urlopen(uni_casefold_url):

    # Save original line
    saveline = line

    # Save comment then remove it
    m = re.match(r'.*#\s*(.*)', line)
    if m:
        comment = m.group(1)
    else:
        comment = ''
    line = re.sub('#.*', '', line)

    # Strip whitespace; if line blank, do next one
    line = line.strip()
    if not line:
        continue

    if re.match(r'([0-9A-F]+); F; (([0-9A-F]+)( [0-9A-F]+)*);$', line):
        errout("Warning: Can't handle full mapping: %s", saveline)
        outout(";;; WARNING: Unhandled full mapping:\n;;;   %s", saveline)
        continue
    if re.match(r'([0-9A-F]+); T; ([0-9A-F]+);$', line):
        errout("Warning: Can't handle Turkish mapping: %s", saveline)
        outout(";;; WARNING: Unhandled Turkish mapping:\n;;;        %s",
               saveline)
        continue
    m = re.match(r'([0-9A-F]+); [CS]; ([0-9A-F]+);$', line)
    if not m:
        errout("Warning: Unrecognized line: %s", saveline)
        outout(";;; WARNING: Unrecognized line:\n;;;   %s", saveline)
        continue

    def tounichar(val):
        if val <= 0xFFFF:
            return r'?\u%04X' % val
        else:
            return r'?\U%08X' % val
    upper = tounichar(int(m.group(1), 16))
    lower = tounichar(int(m.group(2), 16))
    print r'       (%s %s) ;; %s' % (upper, lower, comment)

print """\
       )
  with case-table = (standard-case-table)
  do
  (put-case-table-pair upper lower case-table))

(provide '%s)

;;; %s ends here""" % (output_filename.replace(".el",""), output_filename)

## Another version, trying to diagnose byte-compiler underflow error caused
## by these additions
#print """\
#       )
#  with case-table = (standard-case-table)
#  do
#  (let* ((existing-lower (get-case-table 'downcase upper case-table))
#	 (existing-lower (and (not (eq existing-lower upper)) existing-lower)))
#    ;;(when (not (eq (char-charset lower) (char-charset upper)))
#    ;;  (princ (format "Upper %s (%s) not same charset as lower %s (%s)" upper (char-charset upper) lower (char-charset lower))))
#    (cond ((eq existing-lower lower)
#	   ;;(princ (format "Already seen mapping %s for char %s" lower upper))
#	   )
#	  (existing-lower
#	   ;;(princ (format "Existing mapping for char %s is %s, different from new %s?" upper existing-lower lower))
#	   )
#	  ((and (not (featurep 'unicode-internal))
#		(not (eq (char-charset lower) (char-charset upper))))
#	   ;;(princ (format "Not adding cross-charset mapping %s -> %s" upper lower))
#	   )
#	  (t
#	   ;;(princ (format "Adding mapping for upper %s -> lower %s" upper lower))
#	   (put-case-table-pair upper lower case-table)
#	   ))))
#"""
#print """\
#(provide '%s)
#
#;;; %s ends here""" % (output_filename.replace(".el",""), output_filename)
